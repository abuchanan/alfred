<html>
  <head>

  </head>
  <body>
    <div id="test"></div>

    <script src="raphael-min.js"></script>
    <script>
      var paper = Raphael(document.getElementById("test"), 200, 200);

      function Point(x, y) {
          this.x = x;
          this.y = y;
      }
      Point.prototype = {
          // TEST that this modifies nothing
          distance_to: function(point) {
              var x = Math.abs(point.x - this.x);
              var y = Math.abs(point.y - this.y);
              return Math.sqrt(x*x + y*y);
          }
      }
      
      function Chain() {
          this.points = [];
      }
      Chain.prototype = {
          get root() { 
              if (this.empty)
                  return false;
              else
                  return this.points[0];
          },
          set root(point) {
              if (this.empty)
                  this.push(point);
              else
                  this.points[0] = point;
          },
          get end() {
              if (this.empty)
                  return false;
              else
                  return this.points[this.points.length - 1];
          },
          set end(point) {
              if (this.empty)
                  this.push(point);
              else
                  this.points[this.points.length - 1] = point;
          },
          // TEST returns 0 when one or zero points
          // TEST returns correct length
          // TEST that this modifies nothing
          get length() {
              var len = 0;
              if (this.points.length < 2) 
                  return len;

              for (var i = 1; i < this.points.length; i++) {
                  var prev = this.points[i - 1];
                  var cur = this.points[i];
                  len += prev.distance_to(cur);
              }
              return len;
          },
          get empty() {
              return this.points.length < 1;
          },
          get path() {
              var path = '';
              if (this.empty) {
                  return path;
              } else {
                  path += 'M ' + this.root.x + ' ' + this.root.y;
                  for (var i = 1; i < this.points.length; i++) {
                      path += ' L ' + this.points[i].x + ' ' + this.points[i].y;
                  }
                  return path;
              }
          },
          // TEST that this modifies nothing
          reachable: function(target) {
              return this.root.distance_to(target) <= this.length;
          },
          push: function(point) {
              this.points.push(point);
          },
      }

      function make_arm() {
          var arm = new Chain();
          var start = new Point(10, 10);
          arm.push(start);

          var joints = 3;
          var seclen = 20;
          for (var i = 0; i < joints; i++) {
              var x = arm.end.x + seclen;
              var y = 10;
              arm.push(new Point(x, y));
          }
          return arm;
      }
      var arm = make_arm();
      console.log(arm.length);

      function draw_arm(paper, arm, color) {
          var set = paper.set();
          for each (var p in arm.points) {
              var c = paper.circle(p.x, p.y, 2);
              c.attr({'fill': color});
              set.push(c);
          }
          var p = paper.path(arm.path);
          set.push(p);
          return set;
      }
      
      function solve(arm, target) {
          var tolerance = 0;
          var ds = [];
          for (var i = 0; i < arm.points.length - 1; i++) {
              ds[i] = arm.points[i].distance_to(arm.points[i + 1]);
          }

          // TODO clean this up
          if (arm.reachable(target)) {
              var b = arm.root;
              var count = 0;
              var thresh = 100;

              while ( (arm.end.distance_to(target) > tolerance) && (count < thresh) ) {
                  arm.end = target;

                  for (var i = arm.points.length - 2; i >= 0; i--) {
                      var p = arm.points[i];
                      var q = arm.points[i + 1];

                      var z = q.distance_to(p);
                      var d = ds[i];
                      var g = d/z;
                      var n = (1 - g);

                      arm.points[i] = new Point(n * q.x + g * p.x, n * q.y + g * p.y);
                  }

                  arm.root = b;
                  for (var i = 1; i < arm.points.length; i++) {
                      var p = arm.points[i];
                      var q = arm.points[i - 1];

                      var z = p.distance_to(q);
                      var d = ds[i - 1];
                      var g = d/z;
                      var n = (1 - g);

                      arm.points[i] = new Point(n * q.x + g * p.x, n * q.y + g * p.y);
                  }
                  count++;
              }
          } else {
          }
          return arm;
    }
          
    var sign = 1;
    var drawn = false;
    var len = 0;
    var incr = 1;
    var target_path = paper.path("M 10 40 L 70 10");
    var target_end = target_path.getTotalLength();
    
    var interval = setInterval(function() {
        point = target_path.getPointAtLength(len);
        var target = new Point(point.x, point.y);

        if (drawn)
            drawn.remove();

        arm = solve(arm, target); 
        drawn = draw_arm(paper, arm, 'green');

        if (len > target_end || len < 0)
            sign = sign * -1;
        len = len + (incr * sign);

    }, 10);

    setTimeout(function() { clearInterval(interval); }, 10000);
    // TEST after solving, segment lengths stay the same

    </script>
  </body>
</html>
